npx create-react-app . --template typescript
// crea un proyecto de react en la carpeta local

npm test
// corre los tests en modo escucha

test (name, fn, timeout)
name: nombre para identificar el test
fn: funcion que contiene lo que espera testear el test
timeout: tiemppo a esperar antes de abortar el test (default 5 segundos)

screen permite usar el dom (screen.getByText(/learn react/i) busca el texto learn react)
expect es como el assert

En getByText puedo pasr un texto screen.getByText('Hello') o una expresion regular screen.getByText(/hello/i)
el /i del final es para que no distinga mayusculas y minusculas

jest watch mode:
watch mode is an option that ew con pass to jest asking to watch files that have changed since last commit
and execute tests related only to those changed files
An optimization designed to make your tests run fast regardless on how many tests you have

Si el lugoar de usar test('Greet renders with a name', () => {
uso test.only('Greet renders with a name', () => { me va a correr solo ese test
test.skip('Greet renders with a name', () => { me va a omitir este test

Agrupar tests
-------------

describe(name, fn)
name: el nombre del grupo
fn: una funcion que contiene lo que se va a testear

se puede usar .skip y .only en describe
Se puede anidar los describe() y peuede haber varios por archivo.
describe no hace que sea un test suite separado, cada archivo es un test suite.

coonvenciones
------------
archivos con sufijo .test.js o .test.jsx
archivos con sufijo .spec.js o .spec.jsx
archivos con sufijo .js o .jsx que este dentro de carpetas llamadas __tests__ 

se puede usar it o test para hacer los tests
test('renders correctly', () => {
it('renders correctly', () => {

fit() es lo mismo que test.only()
xit() es lo mismo que test.skip()

code coverage
-------------

statement coverage: how many of the statements in the software code have been executed
branches coverage: how many of the branches of the control structures (i.e. if statement) have been executed
function coverage: how many of the functions defined hav been called and finally
line coverage: how many lines of source code have been tested

assertions
----------

expect(value)
the argument should be the value that your code produces

jest.io/docs/using-matchers

Algunos matchers como toBeInTheDocument no son parte de jest, son de una lib adicional llamada jest-dom

what to test
------------
test comopnent renders
test comopnent renders with props
test component renders in different states (ej si depede de si el usuario esta logueado)
test component reacts to events

what not to test
----------------
implementation details
third party code
code that is not important from an user point of view 
(ej no testear como se llamo a la funcion sino testear como se mostro el resultado)

RTL queries
-----------
Every test we write generally involves the following basic steps
1) Render the component
2) Find an element rendered by the component
3) test against the element found in step 2 which will pass or fail the test

To render the component, we use the render method from RTL (1)
For assertion, we use expect passing in a value and combine it with a matcher function from jest or jest-dom (3)
Queries are methods that testing library provides to find elements on the page (2)
to find a single element on the page, we have
-getBy...
-queryBy...
-findBy...
to find multiple elements on the page, we have
-getAllBy...
-queryAllBy...
-findAllBy...
The suffix can be one of Role, LabelText, PlaceHolderText, Text, DisplayValue, AltText, Title and finally TestId

getBy..
getBy.. class of queries return the matching node for a query, and throw a descriptive error if no elements match 
or if more than one match is found
The suffix can be one of Role, LabelText, PlaceHolderText, Text, DisplayValue,
AltText, Title and finally TestId

getByRole
getByRole queries for elements with the given Role
Role refers to the ARIA (Accessible Rich Internet Applications) role which provides semantic meaning to content to 
ensure people using assistive technologies are able to use them

By default, many semantic elements in HTML have a role
Button element has a button role, anchor element has a link role, h1 to h6 elements have a heading role, checkboxes 
have a checkbox role, radio buttons have a radio role and so on
If you're working with elements that do not have a default role or if you want to specify a different role, the role 
attribute can be used to add the desired role
To use an anchor element as a button in the navbar, you coan add role='button'

para saber que role tien cada tipo de widget, puedo ir a https://testing-library.com/docs/queries/byrole y clickear 
en "a table of HTML elements with their default and desired roles" (https://www.w3.org/TR/html-aria/#docconformance)

getByRole Options
-----------------

Name:
The accessible name is for simple cases equal to 
1) the label of a form element
2) the text content for a button or
3) the value of the aria-label attribute

getByRole Options: name, level, hidden, selected, checked, pressed

getByLabelText
--------------
getByLabelText will search for the label that matches the givent text, then find the element associated with that 
label
